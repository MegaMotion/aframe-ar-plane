<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello, World! • A-Frame three.ar.js</title>
    <meta name="description" content="Hello, World! • A-Frame three.ar.js">
    <script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
    <script src="https://rawgit.com/google-ar/three.ar.js/master/dist/three.ar.js"></script>
<!--
    <script src="https://rawgit.com/chenzlabs/aframe-ar/experimental-planes/dist/aframe-three-ar-planes.js"></script>
-->
    <script src="aframe-three-ar-planes.js"></script>
    <script src="https://rawgit.com/chenzlabs/aframe-ar/experimental-planes/dist/aframe-ar.js"></script>
  </head>
  <body>    
    <script>
      AFRAME.registerComponent('thing', {
        init: function () {
          this.el.setAttribute('geometry', {primitive:'box', width:0.01, depth:0.01, height:1});
          this.el.setAttribute('position', {y:0.5});
        }
      });            
    </script>

    <script>
      // May want to try alternative approach where
      // ar-raycaster responds to raycast-intersection-cleared
      // (from normal raycaster)
      // by trying AR hit instead...
      // but current exposed API does not support ray orientation as input.
      AFRAME.registerComponent('ar-raycaster', {      
        schema: {
          x: {default: 0.5},
          y: {default: 0.5},
          //interval: { default: 100 }
          el: {type: 'selector'}
        },
        
        dependencies: ['raycaster'],
        init: function () {
          this.raycaster = this.el.components['raycaster'].raycaster;
          this.raycasterIntersectObjects = this.raycaster.intersectObjects.bind(this.raycaster);
          this.raycaster.intersectObjects = this.intersectObjects.bind(this);
        },
        intersectObjects: function (objects, recursive) {
          // Tack on AR hit result, if any.
          return this.raycasterIntersectObjects(objects, recursive)
            .concat(this.hitAR());
        },        
        hitAR: (function () {
          
          // Temporary variables, only within closure scope.
          var transform = new THREE.Matrix4();
          var hitpoint = new THREE.Vector3();
          var hitquat = new THREE.Quaternion();
          var hitscale = new THREE.Vector3();
          
          // The desired function, which this returns.
          return function () {
            var threear = this.el.sceneEl.components['three-ar'];
            if (!threear || !threear.arDisplay || !threear.arDisplay.hitTest) { return []; }

            var hit = threear.arDisplay.hitTest(this.data.x, this.data.y);

            if (hit && hit.length > 0) {
              // At least one hit.
              // For now, only process the first hit.
              // FIXME: really should do a raycast and only hit "ground" if missed
              transform.fromArray(hit[0].modelMatrix);
              transform.decompose(hitpoint, hitquat, hitscale);
              return [{
                distance: hitpoint.distanceTo(this.el.object3D.position), // Is that right point?
                point: hitpoint, // Vector3
                object: this.data.el || this.el
/*
                // We don't have any of these properties...
                face: undefined, // Face3
                faceIndex: undefined,
                index: undefined,
                object: undefined, // usually a Mesh
                uv: undefined // Vector2                
*/                  
                }];
            } else {
              return [];
            }         
          }        
        })()
/*        
        init: function () {
          this.tick = AFRAME.utils.throttleTick(this.tick, this.data.interval, this);
        },
        
        // TODO: update
        
        tick: (function () {
          
          // Temporary variables, only within closure scope.
          var transform = new THREE.Matrix4();
          var hitpoint = new THREE.Vector3();
          var hitquat = new THREE.Quaternion();
          var hitscale = new THREE.Vector3();
          
          // The desired function, which this returns.
          return function () {
            var threear = this.el.sceneEl.components['three-ar'];
            if (!threear || !threear.arDisplay || !threear.arDisplay.hitTest) { return; }

            var hit = threear.arDisplay.hitTest(this.data.x, this.data.y);

            if (hit && hit.length > 0) {
              // At least one hit.
              // For now, only process the first hit.
              // FIXME: really should do a raycast and only hit "ground" if missed
              transform.fromArray(hit[0].modelMatrix);
              transform.decompose(hitpoint, hitquat, hitscale);
              this.hitEl = this.el;
              this.el.emit('raycaster-intersection', {
                els: [this.hitEl], 
                intersections: [{
                  distance: hitpoint.distanceTo(this.el.object3D.position), // Is that right point?
                  point: hitpoint, // Vector3

                  // We don't have any of these properties...
                  face: undefined, // Face3
                  faceIndex: undefined,
                  index: undefined,
                  object: undefined, // usually a Mesh
                  uv: undefined // Vector2                
                  }]
              });
            } else {
              // No longer hit.
              if (this.hitEl) {
                var wasHitEl = this.hitEl;
                delete this.hitEl;
                this.el.emit('raycaster-intersection-cleared', {el: wasHitEl});
              }
            }         
          }        
        })()
*/        
      });
    </script>
    
    <a-scene ar>
      <a-sphere id="ball" radius="0.01" position="0 0.005 -0.5"></a-sphere>
      
      <a-entity id="background" ar-raycaster></a-entity>
      
      <a-camera>
        <a-sphere id="dot" color="red" radius="0.001" position="0 0 -0.4"></a-sphere>
        <a-text id="hud" 
                scale="0.01 0.01 0.01" position="0 -0.025 -0.1" 
                color="red" align="center" 
                value="Hi there"></a-text>
      </a-camera>
    </a-scene>    
    
    <script>
      var sc = document.querySelector('a-scene');
      function showHUD(msg) { sc.querySelector('#hud').setAttribute('value', msg); }
      
      function onCreateOrUpdatePlane(evt) {
        var plane = sc.querySelector('#plane_' + evt.detail.id);
        if (!plane) {
          plane = document.createElement('a-box');
          plane.setAttribute('id', 'plane_' + evt.detail.id);
          plane.setAttribute('color', 'red');
          plane.setAttribute('opacity', 0.2);
          plane.setAttribute('height', 0.001);
          sc.appendChild(plane);
          
          plane.insertAdjacentHTML('beforeend', 
            '<a-entity class="label" rotation="-90 0 0"></a-entity><a-entity thing></a-entity>');
        }
        plane.setAttribute('width', evt.detail.extent.x);
        plane.setAttribute('depth', evt.detail.extent.z);
        plane.setAttribute('position', evt.detail.position);
        plane.setAttribute('rotation', evt.detail.rotation);
        plane.setAttribute('scale', evt.detail.scale);
        
        plane.querySelector('.label').setAttribute('text', {
         width: plane.getAttribute('width'), 
         height: plane.getAttribute('depth'), 
         align: 'left',
         wrapCount: 100, value: 
          'id: ' + plane.getAttribute('id')
        + '\nwidth: ' + plane.getAttribute('width')
        + '\ndepth: ' + plane.getAttribute('depth')
        + '\nposition x: ' + plane.getAttribute('position').x
        + '\nposition y: ' + plane.getAttribute('position').y
        + '\nposition z: ' + plane.getAttribute('position').z
        + '\nrotation x: ' + plane.getAttribute('rotation').x
        + '\nrotation y: ' + plane.getAttribute('rotation').y
        + '\nrotation z: ' + plane.getAttribute('rotation').z
        + '\nscale x: ' + plane.getAttribute('scale').x
        + '\nscale y: ' + plane.getAttribute('scale').y
        + '\nscale z: ' + plane.getAttribute('scale').z
        });
        return plane;
      }      
      
      function onRemovePlane(evt) {
        var plane = sc.querySelector('#plane_' + evt.detail.id);
        if (plane && plane.parentElement) { plane.parentElement.removeChild(plane); }
      }      
      
      function addEventListeners() {
        sc.addEventListener('createplane', onCreateOrUpdatePlane);
        sc.addEventListener('updateplane', onCreateOrUpdatePlane);
        sc.addEventListener('removeplane', onRemovePlane);
        
        var background = sc.querySelector('#background');
        // Note, -intersection is what the raycaster gets; the hit object gets -intersected.
        background.addEventListener('raycaster-intersection', function (evt) {
          showHUD('raycaster-intersection');
          ball.setAttribute('position', evt.detail.intersections[0].point);
          ball.setAttribute('visible', true);
        });
        background.addEventListener('raycaster-intersection-cleared', function (evt) {
          showHUD('raycaster-intersection-cleared');
          ball.setAttribute('visible', false);
        });
      }
      
      function onSceneLoaded() { 
        addEventListeners(); 
      }
      
      if (sc.hasLoaded) { onSceneLoaded(); }
      else { sc.addEventListener('loaded', onSceneLoaded); }
    </script>
  </body>
</html>